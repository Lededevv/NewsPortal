[{"model": "news.post", "pk": 1, "fields": {"author": 3, "article": false, "time_in": "2025-06-17T12:05:05.671Z", "heading": "ХоккейКанада11", "text": "тратартаратратаратртаратртатра", "rating_post": 5.0}}, {"model": "news.post", "pk": 2, "fields": {"author": 3, "article": false, "time_in": "2025-06-17T12:20:36.142Z", "heading": "Основные факторы развития экономики страны", "text": "Один иghз клюdчевых треков предстоящего ПМЭФа звучит так: «Мировая экономика – новая платформа глобального роста». За последние несколько месяцев мировая экономика пережила не просто ряд шоков, а настоящих тектонических сдвигов.", "rating_post": 3.0}}, {"model": "news.post", "pk": 4, "fields": {"author": 1, "article": false, "time_in": "2025-06-22T15:18:55.353Z", "heading": "Медведев уступил Бублику в финале турнира в Халле", "text": "Российский теннисист Даниил Медведев проиграл представителю Казахстана Александру Бублику в финале турнира категории ATP 500 в Халле (Германия), призовой фонд которого превышает 2,5 миллиона евро.", "rating_post": 5.0}}, {"model": "news.post", "pk": 5, "fields": {"author": 3, "article": true, "time_in": "2025-06-24T07:18:39.886Z", "heading": "Трамп провацирует падение рынка", "text": "Рынки капитала подвержены влиянию множества различных факторов — экономических, финансовых и политических. Однако среди всех видов воздействий особое внимание привлекает использование геополитики как инструмента манипуляции рынком. Это явление встречается достаточно часто и проявляется во множестве форм, включая целенаправленное распространение ложных новостей, создание искусственной паники или спекуляций вокруг реальных событий.", "rating_post": 3.0}}, {"model": "news.post", "pk": 7, "fields": {"author": 1, "article": true, "time_in": "2025-06-24T07:48:38.345Z", "heading": "Новый рекорд температуры зафиксирован в Сочи", "text": "Жара достигла отметки +40 градусов Цельсия, местные власти призывают жителей соблюдать меры предосторожности и пить больше воды.", "rating_post": 2.0}}, {"model": "news.post", "pk": 8, "fields": {"author": 3, "article": false, "time_in": "2025-06-24T07:49:13.886Z", "heading": "Россияне стали чаще путешествовать по стране.", "text": "Туристические направления Крыма, Кавказа и Карелии привлекают всё больше туристов благодаря доступным ценам и качественным сервисам.", "rating_post": 2.0}}, {"model": "news.post", "pk": 10, "fields": {"author": 1, "article": false, "time_in": "2025-06-24T07:50:54.808Z", "heading": "Российские школьники завоевали медали на международной олимпиаде по математике.", "text": "Победители получили золотые награды, продемонстрировав высокий уровень подготовки и талант учеников отечественных школ.пр", "rating_post": 8.0}}, {"model": "news.post", "pk": 14, "fields": {"author": 1, "article": false, "time_in": "2025-06-24T07:53:40.743Z", "heading": "Открылась новая ветка метро в Москве.", "text": "Жители столицы оценили удобство маршрута, значительно сократившего время поездок в отдалённые районы города.", "rating_post": 6.0}}, {"model": "news.post", "pk": 15, "fields": {"author": 3, "article": false, "time_in": "2025-06-24T07:54:11.013Z", "heading": "Крупнейший российский завод электроники увеличил производство смартфонов.", "text": "Компания планирует выйти на международный рынок, конкурируя с ведущими брендами Азии и Европы.", "rating_post": 6.0}}, {"model": "news.post", "pk": 18, "fields": {"author": 3, "article": false, "time_in": "2025-06-24T07:55:47.413Z", "heading": "Создан новый препарат против диабета второго типа.", "text": "Российские медики провели успешные клинические исследования лекарства, доказавшего свою эффективность и безопасность.", "rating_post": 4.0}}, {"model": "news.post", "pk": 19, "fields": {"author": 1, "article": false, "time_in": "2025-06-24T07:56:28.277Z", "heading": "Челябинск стал лидером экологического рейтинга городов России.", "text": "Город внедрил современные технологии переработки отходов и очистку воздуха, улучшив качество жизни горожан.", "rating_post": 4.0}}, {"model": "news.post", "pk": 22, "fields": {"author": 3, "article": false, "time_in": "2025-06-24T07:58:02.759Z", "heading": "Путешественники открыли новую пещеру на Урале.", "text": "Геологи изучают уникальные минералы и останки древних животных, найденные в ранее неизведанной части подземелья.asdasd", "rating_post": 5.0}}, {"model": "news.post", "pk": 24, "fields": {"author": 3, "article": false, "time_in": "2025-06-26T14:10:26.739Z", "heading": "угроза финансовой стабильност", "text": "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk", "rating_post": 0.0}}, {"model": "news.post", "pk": 26, "fields": {"author": 1, "article": false, "time_in": "2025-06-26T14:55:29.441Z", "heading": "Флейта: инструмент гармонии и вдохновения", "text": "Флейта — музыкальный инструмент, известный с древних времен своим мягким и нежным звучанием. Она относится к группе деревянных духовых инструментов и широко используется в классической музыке, джазе, фольклоре разных народов.  Флейта способна передавать широкий спектр эмоций, от легкости и радости до глубокой меланхолии. Ее звучание очаровывает слушателей и вдохновляет музыкантов. Классическая поперечная флейта популярна в симфонических оркестрах, ансамблях и сольных выступлениях, создавая уникальные музыкальные произведения и оставляя незабываемые впечатления.", "rating_post": 0.0}}, {"model": "news.post", "pk": 43, "fields": {"author": 1, "article": false, "time_in": "2025-07-05T17:37:04.195Z", "heading": "это проверка рассылки по мылу", "text": "Электронная почта (email) — удобный инструмент обмена письмами и файлами через интернет. Простота использования и мгновенная доставка делают email незаменимым каналом общения как в личной жизни, так и в бизнесе. За годы эволюции появился огромный выбор сервисов и клиентов для удобной работы с почтой.", "rating_post": 0.0}}, {"model": "news.post", "pk": 44, "fields": {"author": 3, "article": false, "time_in": "2025-07-05T17:49:21.102Z", "heading": "Наука: двигатель прогресса человечества", "text": "еоретического осмысления полученных данных. Научные исследования позволяют раскрывать тайны Вселенной, понимать механизмы природных явлений и находить практические решения глобальобщества.\r\n\r\nИстория науки насчитывает тысячи лет, начиная с древних цивилизаций Египта, Греции и Китая, и вплоть до наших дней, когда наука стала неотъемлемой частью повседневной жизни современного человека. Сегодня научные открытия формируют основу технологий, медицины, экономики и культуры.\r\n\r\nНаучные дисциплины охватывают широкий спектр областей знания: физика изучает фундаментальные законы мироздания, химия исследует свойства веществ и материалов, биология объясняет жизнь организмов, астрономия рассматривает Вселенную в целом, психология изучает человеческую психику, а социология и экономика помогают понять общественные процес312652сы и экономику стран.\r\n\r\nСовременная наука развивается стремительно: открываются новые горизонты в изучении космоса, создаются революционные технологии в медицине и биотехнологиях, разрабатываются экологически чистые энергетические системы и перспективные цифровые платформы.\r\nsxfc\r\nГлавная цель науки — улучшение качества жизни людей, повышение эффективности производства, обеспеченkuhk", "rating_post": 0.0}}, {"model": "news.post", "pk": 45, "fields": {"author": 1, "article": false, "time_in": "2025-07-05T18:02:22.807Z", "heading": "вапвыапимвфапир", "text": "мммммммммывапирыувеаприииииииипывапимсымммммыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыcvcvcxzfzxfvccvbcvbvыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыыxzcx1zccvсва1пвe11111211мxc1йd1cdcdx", "rating_post": 0.0}}, {"model": "news.post", "pk": 46, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T11:15:26.668Z", "heading": "трарарарарара", "text": "Чтобы передать категорию в шаблон письма, вам нужно учитывать, что у одного поста может быть несколько категорий. Поэтому лучше передавать список категорий, а затем выводить их названия в шаблоне удобным спосо1бом.", "rating_post": 0.0}}, {"model": "news.post", "pk": 47, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T11:17:04.702Z", "heading": "йцуывчас", "text": "Теперь перед отправкой письма ищется соответствующий пользователь по адресу электронной почты, и имя пользователя передается в HTML-шаблон вместе с остальным контентом.\r\nСообщение: Штампуется индивидуальное письмо для каждого подписчика, включающее его имя в приветствии.\r\nЛогика обработки: Мы проверяем существование имени пользователя перед попыткой формирования письма, чтобы исключить ситуации, когда нельзя однозначно сопоставить пользователя с email.", "rating_post": 0.0}}, {"model": "news.post", "pk": 48, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T11:24:12.442Z", "heading": "12345", "text": "Новый сигнал notify_subscribers_m2m(): Этот сигнал обрабатывается при любом изменении связей many-to-many (получении или удалении категорий). Здесь используются две основные ветви обработки:\r\nПроверяется действие action и выполняется обработка только при добавлении категорий (post_add).\r\nИспользуется механизм перезагрузки объекта, чтобы гарантировать получение актуальной версии публикации.", "rating_post": 0.0}}, {"model": "news.post", "pk": 49, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T11:24:54.271Z", "heading": "фцфцуыф", "text": "len(recipients) > 0:\r\n        subject = f\"{instance.heading}\"  # Тема письма совпадает с заголовком поста\r\n\r\n        # Список категорий публикации\r\n        category_names = ', '.join([cat.name for cat in categories])\r\n\r\n        # Выбираем текст в зависимости от события\r\n        event_type = \"Создана новая запись\" if kwargs['created'] else \"Изменена запись\"\r\n        text_body = f'{instance.text[:50]}...'\r\n\r\n        # Цикл по получателям (каждое письмо персонально подписано)\r\n        for email in recipients:\r\n            # Получаем конкретного пользователя по email (чтобы подставить имя)\r\n            user = next((sub for sub in subscribers if sub.email == email), None)\r\n            if not user:\r\n                continue  # Пропускаем пользователя, если его невозможно однозначно определить\r\n\r\n            # Форматируем сообщение с именем пользователя и категориями\r\n            html_message = render_to_string('message_template.html', {\r\n                'type_event': event_tyчpe,\r\n                'username': user.username,      # Имя пользователя\r\n                'categories': category_names,   # Название категорий через запятую\r\n                'subject': subject,             # Заголовок публикации", "rating_post": 0.0}}, {"model": "news.post", "pk": 50, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T11:33:27.447Z", "heading": "ссссссссссссс", "text": "Список категорий публикации\r\n        category_names = ', '.join([cat.name for cat in categories])\r\n\r\n        # Выбираем текст в зависимости от события\r\n        event_type = \"Создана новая запись\" if kwargs['created'] else \"Изменена запись\"\r\n        text_body = f'{instance.text[:50]}...'\r\n\r\n        # Цикл по получателям (каждое письмо персонально подписано)\r\n        for email in recipients:\r\n            # Получаем конкретного пользователя по email (чтобы подставить имя)\r\n            user = next((sub for sub in subscribers if sub.email == email), None)\r\n            if not user:\r\n                continue  # Пропускаем пользователя, если его невозможно однозначно определить\r\n\r\n            # Форматируем сообщение с именем пользователя и категориями\r\n            html_message = render_to_string('message_template.html', {\r\n                'type_event': event_type,\r\n                'username': user.username,      # Имя пользователя\r\n                'categories': category_names,   # Название категорий через запятую", "rating_post": 0.0}}, {"model": "news.post", "pk": 51, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T11:42:43.601Z", "heading": "спрсапрвапр", "text": "category in categories:\r\n            subscribers = category.subscribers.all()\r\n            for subscriber in subscribers:\r\n                recipients.add(subscriber.email)\r\n\r\n        if len(recipients) > 0:\r\n            subject = f\"{instance.heading}\"  # Заголовок письма соответствует заголовку поста\r\n            event_type = \"Добавлен новый пост\"  # Тип события\r\n            text_body = f'{instance.text[:50]}...'  # Ограничиваем длину текста до первых 50 символов\r\nк\r\n            # Объединяем названия категорий\r\n            category_names = ', '.join([cat.name for cat in categories])\r\n\r\n            # Рассылка письма каждому подписчику\r\n            for email in recipients:\r\n                user = next((sub for sub in subscribers if sub.email == email), None)\r\n                if not user:\r\n                    continue  # Игнорируем пользователя, если не найден\r\n\r\n                # Генерируем сообщение с использованием шаблона\r\n                html_message = render_to_string('message_template.html', {\r\n                    'type_event': event_type,\r\n                    'username': user.username,\r\n                    'categories': category_names,\r\n                    'subject': subject,\r\n                    'body_text': text_body\r\n                })\r\n\r\n                # Создаем и отправляем письмо\r\n                msg = EmailMultiAlternatives(\r\n                    subject=f'Новость портала: {subject}',\r\n                    body='',  # Нет обычного текста, так как используем HTML\r\n                    from_email=settings.DEFAULT_FROM_EMAIL,\r\n                    to=[email]\r\n                )\r\n                msg.attach_alternative(html_message, \"text/html\")\r\n\r\n                try:\r\n                    msg.send()\r\n                    logger.info(f\"Письмо отправлено на {email} успешно.\")\r\n                except Exception as e:\r\n                    logger.error(f\"Ошибка отправки письма на {email}: {str(e)}\")\r\n\r\n# Оставляем оригинальный сигнал post_save для обычной обработки создания/изменения поста\r\n@receiver(post_save, sender=Post)\r\ndef notify_subscribers_post_save(sender, instance, created, **kwargs):\r\n    \"\"\" Простая отправка уведомлений при непосредственном сохранении поста. \"\"\"\r\n    if created:\r\n        # Ничего не делаем при простом создании поста, \r\n        # поскольку работа с many-to-many обработана отдельным сигналом\r\n        return\r\n\r\n    # Остальные случаи обработки можно оставить пустыми, \r\n    # если обычная логика изменения поста не требует специальной реакции\r\nКлючевые моменты, учтенные в новом коде:\r\nИспользование сигнала m2m_changed: Этот сигнал срабатывает только при изменении отношений many-to-many, позволяя своевременно реагировать на добавленные категории.\r\nФильтрация действий: Из множества вариантов действия (pre_clear, post_clear, pre_add, post_add, ...) мы выбрали только post_add, так как хотим отправлять уведомления только при добавлении новых категорий к посту.\r\nСбор подписчиков: Через цикл собираем всех подписчиков каждой категории, которой принадлежит опубликованный пост.\r\nГенерация HTML-сообщений: Каждое письмо персонализировано, включает имя пользователя и заголовок публикации.\r\nРезюме:\r\nПрименяя два отдельных сигнала (post_save и m2m_changed), мы обеспечиваем гибкость и точность отправки уведомлений. Основное внимание уделяется процессу добавления категорий к посту, что гарантирует, что пользователи получат уведомления вовремя.", "rating_post": 0.0}}, {"model": "news.post", "pk": 52, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T11:46:18.167Z", "heading": "ыуыуыуыуыууы", "text": "Стандартный сигнал post_save: Он больше служит вспомогательной функцией, так как основная обработка будет осуществляться через сигнал m2m_changed.\r\nДополнительная проверка: Убедись, что каждая категория имеет привязанных подписчиков. Если ни одна категория не привязана к новым сообщениям, уведомления отправляться не будут.\r\nТестированыие:\r\nПеред развертыванием убедись, что все модели и их взаимосвязи работают должным образом. Ты можешь протестировать проект локально, проверив реакцию на добавление нового поста и последующ", "rating_post": 0.0}}, {"model": "news.post", "pk": 53, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T11:52:16.676Z", "heading": "яывсыва", "text": "ячсУдалил прямой вызов notify_subscribers_m2m() из сигнала post_save. Вместо этого оставили простую проверку наличия создания или обновления поста, но никакой дополнительной логики отправки уведомлений не добавляли, так как она уже осуществляется корректно в сигнале m2m_changed.\r\nОбновил сигнальный обработчик m2m_changed, чтобы он корректно работал и не ожидал вызова извне.цуц", "rating_post": 0.0}}, {"model": "news.post", "pk": 54, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T11:55:42.527Z", "heading": "аеаееа", "text": "!DOCTYPE html>\r\n<html lang=\"ru\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Новая статья в вашей любимой рубрике</title>\r\n    <style> body { font-family: Arial, Helvetica, sans-serif; color: #333; background-color: #fff; padding: 20px; } h1 { font-size: 24px; margin-bottom: 10px; } p { font-size: 16px; line-height: 1.5; } </style>\r\n</head>\r\n<body>\r\n    <h1>Здравствуй, {{ username }}!</h1>\r\n    <p>{{ type_event }} вашей любимой рубрике:{{categories}}</p>\r\n    <h2>{{ subject }}</h2>\r\n    <p>{{ body_text }}...</p>\r\n    <p>С уважением, команда нашего сайта.</p>\r\n</body>\r\n</html>", "rating_post": 0.0}}, {"model": "news.post", "pk": 55, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T12:07:48.172Z", "heading": "11111111111111111111111111", "text": "!DOCTYPE html>\r\n<html lang=\"ru\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Новая статья в вашей любимой рубрике</title>\r\n    <style> body { font-family: Arial, Helvetica, sans-serif; color: #333; background-color: #fff; padding: 20px; } h1 { font-size: 24px; margin-bottom: 10px; } p { font-size: 16px; line-height: 1.5; } </style>\r\n</head>\r\n<body>\r\n    <h1>Здравствуй, {{ username }}!</h1>\r\n    <p>{{ type_event }} вашей любимой рубрике:{{categories}}</p>\r\n    <h2>{{ subject }}</h2>\r\n    <p>{{ body_text }}...</p>\r\n    <p>С уважением, команда нашего сайта.</p>\r\n</body>\r\n</html>", "rating_post": 0.0}}, {"model": "news.post", "pk": 56, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T12:11:21.323Z", "heading": "ываваритьб исми", "text": "@receiver(m2m_changed, sender=Post.category.through)\r\ndef notify_subscribers_m2m(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    \"\"\" Отправляет уведомления подписчикам при изменении связи между Постом и Категориями. \"\"\"\r\n    logger.debug(f\"Received signal: sender={sender}, instance={instance}, action={action}\")  # Трассировка начала обработки\r\n\r\n    if action == 'post_add':  # Обрабатываем только после добавления категорий\r\n        categories = instance.category.all()\r\n        logger.debug(f\"Categories assigned: {categories}\")  # Проверка назначенных категорий\r\n\r\n        recipients = set()  # Уникальные email подписчиков\r\n\r\n        # Собираем подписчиков каждой категории\r\n        for category in categories:\r\n            subscribers = category.subscribers.all()\r\n            logger.debug(f\"Subscribers for category {category}: {subscribers}\")  # Проверка подписчиков\r\n            for subscriber in subscribers:\r\n                recipients.add(subscriber.email)\r\n\r\n        if len(recipients) > 0:\r\n            subject = f\"{instance.heading}\"  # Заголовок письма совпадает с заголовком поста\r\n            event_type = \"Создан новый пост\"  # Всегда считаем, что создаётся новый пост\r\n\r\n            # Составляем текстовую версию тела письма\r\n            text_body = f'{instance.text[:50]}...'\r\n\r\n            # Объединяем названия категорий\r\n            category_names = ', '.join([cat.name for cat in categories])\r\n\r\n            # Рассылка письма каждому подписчику\r\n            for email in recipients:\r\n                # Получаем конкретного пользователя по email\r\n                user = next((sub for sub in subscribers if sub.email == email), None)\r\n                if not user:\r\n                    continue  # Пропускаем пользователя, если не найден\r\n\r\n                # Генерируем сообщение с использованием шаблона\r\n                html_message = render_to_string('message_template.html', {\r\n                    'type_event': event_type,\r\n                    'username': user.username,\r\n                    'categories': category_names,\r\n                    'subject': subject,\r\n                    'body_text': text_body\r\n                })\r\n\r\n                # Создание и отправка письма\r\n                msg = EmailMultiAlternatives(\r\n                    subject=f'News Portal: {subject}',\r\n                    body='',  # Нет обычного текста, так как используем HTML\r\n                    from_email=settings.DEFAULT_FROM_EMAIL,\r\n                    to=[email]\r\n                )\r\n                msg.attach_alternative(html_message, \"text/html\")\r\n\r\n                try:\r\n                    msg.send()\r\n                    logger.info(f\"Письмо отправлено на {email} успешно.\")  # Успех отправки\r\n                except Exception as e:\r\n                    logger.error(f\"Ошибка отправки письма на {email}: {str(e)}\")  # Логи ошибок\r\n        else:\r\n            logger.warning(\"Нет подписчиков для уведомления.\")  # Если нет подписчиков\r\n    else:\r\n        logger.debug(f\"Ignoring other actions ({action}).\")  # Инергируем остальные действия", "rating_post": 0.0}}, {"model": "news.post", "pk": 57, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T12:14:30.389Z", "heading": "ыва", "text": "Просмотр логов: Запусти сервер снова и посмотри на сообщения, которые появляются в консольном выводе или в журналах. Там появятся подробности того, что происходит на каждой стадии.\r\nПроверка базы данных: Открой базу данных и удостоверься, что посты реально получают назначения категоаарий, и эти категории содержат подписчиков.\r\nПочтовая служба: Если письмо не приходит, проверь, корректно ли сконфигурированы настройки отправки почты в Django. Например, если используешь Yandex или Google Mail, убедитесь, что включены нужные права доступа и отправка разрешена.\r\nЕсли приведённые меры не помогли выявить проблему, можно попробовать отключить весь остальной функционал сайта временно и сосредоточиться исключительно на отправке уведомлений, чтобы изолировать источник проблемы.", "rating_post": 0.0}}, {"model": "news.post", "pk": 58, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T12:21:36.148Z", "heading": "смсм", "text": "смсмсмсмсммсasdсссссссссссссссссссссссссссссссссссссссссссссссссссссссс", "rating_post": 0.0}}, {"model": "news.post", "pk": 59, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T12:24:33.049Z", "heading": "asdddddddsaefsadf", "text": "anged, sender=Post.category.through)\r\ndef notify_subscribers_m2m(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    if action == 'post_add':  # обрабатываем только добавление категорий\r\n        # отправляем уведомления после добавления категорий\r\n        send_notification(instance)\r\nЧто делает этот код:\r\nФункция send_notification():Выполняет всю логику отправки уведомлений. Эта функция вызывается двумя способами:\r\nНепосредственно после создания поста (через сигнал post_save).\r\nПосле изменения связей many-to-many (через сигнал m2m_changed).\r\nСигнал post_save:Обеспечивает отправку уведомлений сразу после создания поста, когда ещё нет сформированных связей many-to-many.\r\nСигнал m2m_changed:", "rating_post": 0.0}}, {"model": "news.post", "pk": 60, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T12:26:03.694Z", "heading": "vfd", "text": "ging\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\n# Функциональность отправки письма вынесена в отдельную функцию\r\ndef send_notification(instance, created=False):\r\n    categories = instance.category.all()\r\n    recipients = set()  # уникальные email подписчиков\r\n\r\n    # Собираем подписчиков каждой категории\r\n    for category in categories:\r\n        subscribers = category.subscribers.all()\r\n        for subscriber in subscribers:\r\n            recipients.add(subscriber.email)\r\n\r\n    if len(recipients) > 0:\r\n        subject = f\"{instance.heading}\"  # тема письма равна заголовку поста\r\n        event_type = \"Создана новая запись\" if created else \"Изменена запись\"\r\n        text_body = f'{instance.text[:50]}...'  # первые 50 символов текста\r\n        category_names = ', '.join([cat.name for cat in categories])  # список категорий\r\n\r\n        # Формирование письма\r\n        for email in recipients:\r\n            user = next((sub for sub in subscribers if sub.email == email), None)\r\n            if not user:\r\n                continue  # пропускаем пользователя, если не найден\r\n\r\n            html_message = render_to_string('message_template.html', {\r\n                'type_event': event_type,\r\n                'username': user.username,\r\n                'categories': category_names,\r\n                'subject': subject,\r\n                'body_text': text_body\r\n            })\r\n\r\n            # Создание и отправка письма\r\n            msg = EmailMultiAlternatives(\r\n                subject=f'News Portal: {subject}',\r\n                body='',  # пустой текст, так как используем HTML\r\n                from_email=settings.DEFAULT_FROM_EMAIL,\r\n                to=[email]\r\n            )\r\n            msg.attach_alternative(html_message, \"text/html\")\r\n\r\n            try:\r\n                msg.send()\r\n                logger.info(f\"Письмо отправлено на {email} успешно.\")\r\n            except Exception as e:\r\n                logger.error(f\"Ошибка отправки письма на {email}: {str(e)}\")\r\n\r\n# Сигнал post_save обрабатывает создание поста\r\n@receiver(post_save, sender=Post)\r\ndef notify_subscribers_post_save(sender, instance, created, **kwargs):\r\n    if created:\r\n        # Сразу после создания поста отправляем уведом", "rating_post": 0.0}}, {"model": "news.post", "pk": 61, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T12:33:39.842Z", "heading": "cvccc", "text": "def send_notification(instance, created=False):\r\n    categories = instance.category.all()\r\n    recipients = set()  # уникальные email подписчиков\r\n\r\n    # Собираем подписчиков каждой категории\r\n    for category in categories:\r\n        subscribers = category.subscribers.all()\r\n        for subscriber in subscribers:\r\n            recipients.add(subscriber.email)\r\n\r\n    if len(recipients) > 0:\r\n        subject = f\"{instance.heading}\"  # тема письма равна заголовку поста\r\n        event_type = \"Создана новая запись\" if created else \"Изменена запись\"\r\n        text_body = f'{instance.text[:50]}...'  # первые 50 символов текста\r\n        category_names = ', '.join([cat.name for cat in categories])  # список категорий\r\n\r\n        # Формирование письма\r\n        for email in recipients:\r\n            user = next((sub for sub in subscribers if sub.email == email), None)\r\n            if not user:\r\n                continue  # пропускаем пользователя, если не найден\r\n\r\n            html_message = render_to_string('message_template.html', {\r\n                'type_event': event_type,\r\n                'username': user.username,\r\n                'categories': category_names,\r\n                'subject': subject,\r\n                'body_text': text_body\r\n            })\r\n\r\n            # Создание и отправка письма\r\n            msg = EmailMultiAlternatives(\r\n                subject=f'News Portal: {subject}',\r\n                body='',  # пустой текст, так как используем HTML\r\n                from_email=settings.DEFAULT_FROM_EMAIL,\r\n                to=[email]\r\n            )\r\n            msg.attach_alternative(html_message, \"text/html\")\r\n\r\n            try:\r\n                msg.send()\r\n                logger.info(f\"Письмо отправлено на {email} успешно.\")\r\n            except Exception as e:\r\n                logger.error(f\"Ошибка отправки письма на {email}: {str(e)}\")\r\n\r\n# Сигнал post_save обрабатывает создание поста\r\n@receiver(post_save, sender=Post)\r\ndef notify_subscribers_post_save(sender, instance, created, **kwargs):\r\n    if created:\r\n        # Сразу после создания поста отправляем уведомления\r\n        send_notification(instance, created=True)\r\n\r\n# Сигнал m2m_changed обрабатывает изменения связей many-to-many\r\n@receiver(m2m_changed, sender=Post.category.through)\r\ndef notify_subscribers_m2m(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    if action == 'post_add':  # обрабатываем только добавление категорий\r\n        # отправляем уведомления после добавления категорий\r\n        send_notification(instance)\r\n\r\n# Вручную инициируем сигнал m2m_changed после создания поста\r\n@receiver(post_save, sender=Post)\r\ndef trigger_m2m_signal(sender, instance, created, **kwargs):\r\n    if created:\r\n        # Симулируем сигнал m2m_changed вручную, чтобы обработать назначения категорий\r\n        m2m_changed.send(sender=Post.category.through, instance=instance, action='post_add')", "rating_post": 0.0}}, {"model": "news.post", "pk": 62, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T12:40:18.423Z", "heading": "апрааор", "text": "Когда сигнал срабатывает, он передает следующие аргументы обработчику:\r\n\r\nsender: Класс промежуточной модели, обеспечивающей связь many-to-many.\r\ninstance: Экземпляр модели, чей объект изменил связь.\r\naction: Тип действия (одно из перечисленных ниже):\r\npre_add: Начинается добавление объекта в связь.\r\npost_add: Завершилось добавление объекта в связь.\r\npre_remove: Начинается удаление объекта из связи.\r\npost_remove: Завершилось удаление объекта из связи.\r\npre_clear: Начинается полная очистка всех связей.\r\npost_clear: Завершилась полная очистка всех связей.\r\nreverse: Boolean-значение, указывающее, производится ли операция на стороне целевого объекта или на стороне родительского объекта.\r\nmodel: Связанная модель, участвующая в отношении many-to-many.", "rating_post": 0.0}}, {"model": "news.post", "pk": 63, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T12:41:07.938Z", "heading": "fhfg", "text": "Автоматическая отправка уведомлений при добавлении или удалении участников группы.\r\nСинхронизация статусов и метаданных, связанных с назначением ролей.\r\nОбновление статистики, зависящей от количества назначенных категорий или пользователей.\r\nКак работает сигнал m2m_changed?\r\nСигнал m2m_changed запускается в результате любого изменения связей many-to-many, например:\r\n\r\nДобавление объекта в связь (post_add).\r\nУдаление объекта из связи (post_remove).\r\nПолное очищение всей связи (post_clear).\r\nПроцесс проходит в несколько фаз:\r\n\r\nПодготовка (pre_...):Прежде чем фактически произойдут изменения в связи, сигнал отправляет предварительное предупреждение.\r\nЗавершение (post_...):После того, как изменения завершены, сигнал подтверждает завершение процесса.\r\nКакие параметры принимает сигнал m2m_changed?\r\nКогда сигнал срабатывает, он передает следующие аргументы обработчику:\r\n\r\nsender: Класс промежуточной модели, обеспечивающей связь many-to-many.\r\ninstance: Экземпляр модели, чей объект изменил связь.\r\naction: Тип действия (одно из перечисленных ниже):\r\npre_add: Начинается добавление объекта в связь.\r\npost_add: Завершилось добавление объекта в связь.\r\npre_remove: Начинается удаление объекта из связи.\r\npost_remove: Завершилось удаление объекта из связи.\r\npre_clear: Начинается полная очистка всех связей.\r\npost_clear: Завершилась полная очистка всех связей.\r\nreverse: Boolean-значение, указывающее, производится ли операция на стороне целевого объекта или на стороне родительского объекта.\r\nmodel: Связанная модель, участвующая в отношении many-to-many.\r\npk_set: Набор первичных ключей объектов, участвующих в изменении.\r\nПример использования сигнала m2m_changed:\r\nПредположим, у нас есть модель статей (Post) и модель категорий (Category), связанные отношением many-to-many. Хочется отправлять уведомления подписчикам, когда статье назначают новую категорию.\r\n\r\n\r\nfrom django.db.models.signals import m2m_changed\r\nfrom django.dispatch import receiver\r\nfrom django.core.mail import send_mail\r\nfrom django.conf import settings\r\n\r\n@receiver(m2m_changed, sender=Post.category.through)\r\ndef notify_on_category_change(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    if action == 'post_add':  # обрабатываем только добавление категорий\r\n        added_categories = model.objects.filter(pk__in=pk_set)\r\n        for category in added_categories:\r\n            subscribers = category.subscribers.all()\r\n            for subscriber in subscribers:\r\n                send_mail(\r\n                    subject=f\"Ваша категория была назначена статье\",\r\n                    message=f\"Статья {instance.title} получила новую категорию.\",\r\n                    from_email=settings.DEFAULT_FROM_EMAIL,\r\n                    recipient_list=[subscriber.email]\r\n                )\r\nОсобенности использования сигнала m2m_changed:\r\nАсинхронность: Несмотря на то, что сигнал m2m_changed асинхронен, разработчики могут спокойно использовать его для простых задач, не нагружающих систему.\r\nПорядок исполнения: Если изменение связи происходит в рамках транзакции, сигнал будет отправлен после фиксации транзакции.\r\nСовместимость с ORM: Следует помнить, что сигнал не сработает, если изменять связи не через методы ORM, а вручную, например, через raw SQL-запросы.\r\nЗаключение:\r\nСигнал m2m_changed крайне удобен для разработчиков, нуждающихся в контроле динамики отношений many-to-many. Благодаря широкому спектру возможностей обработки различных событий, он существенно упрощает построение приложений с мощными возможностями синхронизации и уведомлений.\r\n\r\n\r\nСообщение", "rating_post": 0.0}}, {"model": "news.post", "pk": 64, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T12:41:50.710Z", "heading": "f", "text": "Автоматическая отправка уведомлений при добавлении или удалении участников группы.\r\nСинхронизация статусов и метаданных, связанных с назначением ролей.\r\nОбновление статистики, зависящей от количества назначенных категорий или пользователей.\r\nКак работает сигнал m2m_changed?\r\nСигнал m2m_changed запускается в результате любого изменения связей many-to-many, например:\r\n\r\nДобавление объекта в связь (post_add).\r\nУдаление объекта из связи (post_remove).\r\nПолное очищение всей связи (post_clear).\r\nПроцесс проходит в несколько фаз:\r\n\r\nПодготовка (pre_...):Прежде чем фактически произойдут изменения в связи, сигнал отправляет предварительное предупреждение.\r\nЗавершение (post_...):После того, как изменения завершены, сигнал подтверждает завершение процесса.\r\nКакие параметры принимает сигнал m2m_changed?\r\nКогда сигнал срабатывает, он передает следующие аргументы обработчику:\r\n\r\nsender: Класс промежуточной модели, обеспечивающей связь many-to-many.\r\ninstance: Экземпляр модели, чей объект изменил связь.\r\naction: Тип действия (одно из перечисленных ниже):\r\npre_add: Начинается добавление объекта в связь.\r\npost_add: Завершилось добавление объекта в связь.\r\npre_remove: Начинается удаление объекта из связи.\r\npost_remove: Завершилось удаление объекта из связи.\r\npre_clear: Начинается полная очистка всех связей.\r\npost_clear: Завершилась полная очистка всех связей.\r\nreverse: Boolean-значение, указывающее, производится ли операция на стороне целевого объекта или на стороне родительского объекта.\r\nmodel: Связанная модель, участвующая в отношении many-to-many.\r\npk_set: Набор первичных ключей объектов, участвующих в изменении.\r\nПример использования сигнала m2m_changed:\r\nПредположим, у нас есть модель статей (Post) и модель категорий (Category), связанные отношением many-to-many. Хочется отправлять уведомления подписчикам, когда статье назначают новую категорию.\r\n\r\n\r\nfrom django.db.models.signals import m2m_changed\r\nfrom django.dispatch import receiver\r\nfrom django.core.mail import send_mail\r\nfrom django.conf import settings\r\n\r\n@receiver(m2m_changed, sender=Post.category.through)\r\ndef notify_on_category_change(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    if action == 'post_add':  # обрабатываем только добавление категорий\r\n        added_categories = model.objects.filter(pk__in=pk_set)\r\n        for category in added_categories:\r\n            subscribers = category.subscribers.all()\r\n            for subscriber in subscribers:\r\n                send_mail(\r\n                    subject=f\"Ваша категория была назначена статье\",\r\n                    message=f\"Статья {instance.title} получила новую категорию.\",\r\n                    from_email=settings.DEFAULT_FROM_EMAIL,\r\n                    recipient_list=[subscriber.email]\r\n                )\r\nОсобенности использования сигнала m2m_changed:\r\nАсинхронность: Несмотря на то, что сигнал m2m_changed асинхронен, разработчики могут спокойно использовать его для простых задач, не нагружающих систему.\r\nПорядок исполнения: Если изменение связи происходит в рамках транзакции, сигнал будет отправлен после фиксации транзакции.\r\nСовместимость с ORM: Следует помнить, что сигнал не сработает, если изменять связи не через методы ORM, а вручную, например, через raw SQL-запросы.\r\nЗаключение:\r\nСигнал m2m_changed крайне удобен для разработчиков, нуждающихся в контроле динамики отношений many-to-many. Благодаря широкому спектру возможностей обработки различных событий, он существенно упрощает построение приложений с мощными возможностями синхронизации и уведомлений.\r\n\r\n\r\nСообщение", "rating_post": 0.0}}, {"model": "news.post", "pk": 65, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T12:47:54.684Z", "heading": "j", "text": "Django создаст скрытую промежуточную модель с тремя основными полями:\r\n\r\nПервичный ключ (PK) промежуточной модели.\r\nВнешний ключ (FK) на объект Post.\r\nВнешний ключ (FK) на объект Category.\r\nЗачем использовать Post.category.through?\r\nВ сигнале m2m_changed в качестве отправителя (sender) нужно указать именно эту промежуточную модель, потому что сигнал срабатывает именно при изменении состояний этой внутренней таблицы. Если указать просто Post.category, сигнал не сработает, так как сам атрибут category не участвует в процессе отправки сигналов.\r\n\r\nКорректный способ задания отправителя:\r\nВот правильный способ задать отправителя сигнала m2m_changed:\r\n\r\n\r\n@receiver(m2m_changed, sender=Post.category.through)\r\ndef notify_subscribers_m2m(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    # Логика обработчика\r\nПример реальной промежуточной модели:\r\nВ реальности Django создаёт промежуточную модель примерно так (для демонстрации):\r\n\r\n\r\nclass PostCategory(models.Model):\r\n    id = models.AutoField(primary_key=True)\r\n    post = models.ForeignKey(Post, db_column='post_id', related_name='+')\r\n    category = models.ForeignKey(Category, db_column='category_id', related_name='+')\r\n\r\n    class Meta:\r\n        managed = False  # Промежуточная модель управляется самим Django\r\n        auto_created = True\r\n        db_table = 'post_category'\r\nНо обычно тебе не придется обращаться к ней напрямую, так как Django управляет ею автоматически.", "rating_post": 0.0}}, {"model": "news.post", "pk": 66, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T12:48:29.979Z", "heading": "gf", "text": "Django создаст скрытую промежуточную модель с тремя основными полями:\r\n\r\nПервичный ключ (PK) промежуточной модели.\r\nВнешний ключ (FK) на объект Post.\r\nВнешний ключ (FK) на объект Category.\r\nЗачем использовать Post.category.through?\r\nВ сигнале m2m_changed в качестве отправителя (sender) нужно указать именно эту промежуточную модель, потому что сигнал срабатывает именно при изменении состояний этой внутренней таблицы. Если указать просто Post.category, сигнал не сработает, так как сам атрибут category не участвует в процессе отправки сигналов.\r\n\r\nКорректный способ задания отправителя:\r\nВот правильный способ задать отправителя сигнала m2m_changed:\r\n\r\n\r\n@receiver(m2m_changed, sender=Post.category.through)\r\ndef notify_subscribers_m2m(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    # Логика обработчика\r\nПример реальной промежуточной модели:\r\nВ реальности Django создаёт промежуточную модель примерно так (для демонстрации):\r\n\r\n\r\nclass PostCategory(models.Model):\r\n    id = models.AutoField(primary_key=True)\r\n    post = models.ForeignKey(Post, db_column='post_id', related_name='+')\r\n    category = models.ForeignKey(Category, db_column='category_id', related_name='+')\r\n\r\n    class Meta:\r\n        managed = False  # Промежуточная модель управляется самим Django\r\n        auto_created = True\r\n        db_table = 'post_category'\r\nНо обычно тебе не придется обращаться к ней напрямую, так как Django управляет ею автоматически.", "rating_post": 0.0}}, {"model": "news.post", "pk": 67, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T12:58:30.346Z", "heading": "ыа", "text": "# Сигнал m2m_changed обрабатывает изменения связей many-to-many\r\n@receiver(m2m_changed, sender=Post.category.through)\r\ndef notify_subscribers_m2m(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    print( '11111111111111111111111111111')\r\n    if action == 'post_add':  # обрабатываем только добавление категорий\r\n        # отправляем уведомления после добавления категорий\r\n        send_notification(instance) не срабатывает сигнал @receiver(m2m_changed, sender=Post.category.through) проверил принтом. а @receiver(post_save, sender=Post) отрабатывает проверил принтом в чем дело? категории добавляются провер", "rating_post": 0.0}}, {"model": "news.post", "pk": 68, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T13:03:04.031Z", "heading": "основныеfghdfgh", "text": "sender=PostCategory: Здесь мы указываем нашу промежуточную модель PostCategory, поскольку именно она реализует связь many-to-many между Post и Category.\r\ninstance.post: Так как наша промежуточная модель содержит внешний ключ на Post, мы получаем доzxXczступ к самому1 посту через instance.post и передаем его в функцию отправки уведомления.\r\nОбщая схема работыd:\r\nПри создании или редактировании поста Django сохраняет объект Post, а затем формирует записи в промежуточной маподели PostCategory, устанавливающие связь между статьями и категориями.\r\nСигнал m2m_changed срабатывает именно при изменении промежуточной модели (например, при назначении категорий статьям).\r\nНаш обработчик сигнала ждет действия post_add, что означает успешное добавление категории к посту.", "rating_post": 0.0}}, {"model": "news.post", "pk": 69, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T13:30:43.359Z", "heading": "ап", "text": "апапапаппппппппппппппппппппппппппппппппппппппппппппппппппппппппппппппппппп", "rating_post": 0.0}}, {"model": "news.post", "pk": 70, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T13:32:10.971Z", "heading": "s", "text": "from django.db.models.signals import post_save\r\nfrom django.dispatch import receiver\r\nfrom django.core.mail import send_mail\r\nfrom django.conf import settings\r\nfrom .models import Post, Category\r\n\r\n@receiver(post_save, sender=Post)\r\ndef notify_subscribers(sender, instance, created, **kwargs):\r\n    if created:\r\n        # Берём категорию новости\r\n        categories = instance.category.all()\r\n        # Проходим по категориям и собираем подписчиков\r\n        for category in categories:\r\n            subscribers = category.subscribers.all()\r\n            # Формируем тему и тело письма\r\n            subject = f\"Новая новость в категории \\\"{category}\\\": {instance.heading}\"\r\n            message = (\r\n                f\"<p>Уважаемые подписчики категории \\\"{category}\\\"!</p>\\n\"\r\n                f\"<p>Появилась новая новость:</p>\\n\"\r\n                f\"<p>\\\"{instance.heading}\\\"</p>\\n\"\r\n                f\"<p>Краткое содержание: {instance.text[:100]}...</p>\\n\"\r\n                f\"<p>Посмотреть подробную информацию можно по ссылке.</p>\\n\"\r\n            )\r\n            # Отправляем письма всем подписчикам\r\n            for subscriber in subscribers:\r\n                send_mail(\r\n                    subject=subject,\r\n                    message=\"\",  # Используем HTML-шаблон\r\n                    from_email=settings.DEFAULT_FROM_EMAIL,\r\n                    recipient_list=[subscriber.email],\r\n                    html_message=message\r\n                )", "rating_post": 0.0}}, {"model": "news.post", "pk": 71, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T13:33:11.660Z", "heading": "основные", "text": "asdaasdasdasdasddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd", "rating_post": 0.0}}, {"model": "news.post", "pk": 72, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T13:33:51.898Z", "heading": "awdasdasd", "text": "awwwwwwwwwwwwwwdsdfvsdfsdfgcxsfdxfffffffffffffffffffffffffff", "rating_post": 0.0}}, {"model": "news.post", "pk": 73, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T13:35:06.200Z", "heading": "dsed", "text": "dfrom django.db.models.signals import post_save\r\nfrom django.dispatch import receiver\r\nfrom django.core.mail import send_mail\r\nfrom django.conf import settings\r\nfrom .models import Post, Category\r\n\r\n@receiver(post_save, sender=Post)\r\ndef notify_subscribers(sender, instance, created, **kwargs):\r\n    if created:\r\n        # Берём категорию новости\r\n        categories = instance.category.all()\r\n        # Проходим по категориям и собираем подписчиков\r\n        for category in categories:\r\n            subscribers = category.subscribers.all()\r\n            # Формируем тему и тело письма\r\n            subject = f\"Новая новость в категории \\\"{category}\\\": {instance.heading}\"\r\n            message = (\r\n                f\"<p>Уважаемые подписчики категории \\\"{category}\\\"!</p>\\n\"\r\n                f\"<p>Появилась новая новость:</p>\\n\"\r\n                f\"<p>\\\"{instance.heading}\\\"</p>\\n\"\r\n                f\"<p>Краткое содержание: {instance.text[:100]}...</p>\\n\"\r\n                f\"<p>Посмотреть подробную информацию можно по ссылке.</p>\\n\"\r\n            )\r\n            # Отправляем письма всем подписчикам\r\n            for subscriber in subscribers:\r\n                send_mail(\r\n                    subject=subject,\r\n                    message=\"\",  # Используем HTML-шаблон\r\n                    from_email=settings.DEFAULT_FROM_EMAIL,\r\n                    recipient_list=[subscriber.email],\r\n                    html_message=message\r\n                )", "rating_post": 0.0}}, {"model": "news.post", "pk": 74, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T13:36:52.336Z", "heading": "gcv", "text": "ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccg", "rating_post": 0.0}}, {"model": "news.post", "pk": 75, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T13:37:49.214Z", "heading": "ftft", "text": "ftthhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh", "rating_post": 0.0}}, {"model": "news.post", "pk": 76, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T13:55:05.370Z", "heading": "bv vb", "text": "f\"<p>Посмотреть подробную информацию можно по ссылке.</p>\\n\"\r\n            )\r\n            # Отправляем письма всем подписчикам\r\n            for subscriber in subscribers:\r\n                send_mail(\r\n                    subject=subject,\r\n                    message=\"\",  # Используем HTML-шаблон\r\n                    from_email=settings.DEFAULT_FROM_EMAIL,\r\n                    recipient_list=[subscriber.email],\r\n                    html_message=message\r\n                )\r\n2. Настройте отправку email:\r\nУбедитесь, что в вашем проекте настроена отправка писем через SMTP. Минимальная настройка в settings.py:", "rating_post": 0.0}}, {"model": "news.post", "pk": 77, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T14:03:45.113Z", "heading": "Основные", "text": "dfgjhdgfhjndghjndfg123", "rating_post": 0.0}}, {"model": "news.post", "pk": 78, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T14:04:15.560Z", "heading": "wa", "text": "Проверка промежуточной модели: Убедись, что в базе данных корректно создаются записи в промежуточной таблице (например, post_category).\r\nПроставь точку останова: Добавь вывод или breakpoint в сигнале m2m_changed, чтобы убедиться, что он вообще срабатывает.\r\nПроверь присутствие категорий: Убедись, что при создании поста действительно назначаются категории, иначе сигнал не получит данных для обработки.\r\nЕсли вышеуказанные шаги не решат проблему, стоит глубже проанализировать", "rating_post": 0.0}}, {"model": "news.post", "pk": 79, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T14:06:36.853Z", "heading": "aaa", "text": "aaaadef send_notification(instance, created=False):\r\n    categories = instance.category.all()\r\n    recipients = set()  # уникальный набор email подписчиков\r\n\r\n    # Собираем подписчиков каждой категории\r\n    for category in categories:\r\n        subscribers = category.subscribers.all()\r\n        for subscriber in subscribers:\r\n            recipients.add(subscriber.email)\r\n\r\n    if len(recipients) > 0:\r\n        subject = f\"{instance.heading}\"  # тема письма равна заголовку поста\r\n        event_type = \"Создана новая запись\" if created else \"Изменена запись\"\r\n        text_body = f'{instance.text[:50]}...'  # первые 50 символов текста\r\n        category_names = ', '.join([cat.name for cat in categories])  # список категорий\r\n\r\n        # Формирование письма\r\n        for email in recipients:\r\n            user = next((sub for sub in subscribers if sub.email == email), None)\r\n            if not user:\r\n                continue  # пропускаем пользователя, если не найден\r\n\r\n            html_message = render_to_string('message_template.html', {\r\n                'type_event': event_type,\r\n                'username': user.username,\r\n                'categories': category_names,\r\n                'subject': subject,\r\n                'body_text': text_body\r\n            })\r\n\r\n            # Создание и отправка письма\r\n            msg = EmailMultiAlternatives(\r\n                subject=f'News Portal: {subject}',\r\n                body='',  # пустой текст, так как используем HTML\r\n                from_email=settings.DEFAULT_FROM_EMAIL,\r\n                to=[email]\r\n            )\r\n            msg.attach_alternative(html_message, \"text/html\")\r\n\r\n            try:\r\n                msg.send()\r\n                logger.info(f\"Письмо отправлено на {email} успешно.\")\r\n            except Exception as e:\r\n                logger.error(f\"Ошибка отправки письма на {email}: {str(e)}\")\r\n\r\n# Сигнал post_save обрабатывает создание поста\r\n@receiver(post_save, sender=Post)\r\ndef notify_subscribers_post_save(sender, instance, created, **kwargs):\r\n    print(\"asddfasdasdasdasd\")\r\n    if created:\r\n        # Сразу после создания поста отправляем уведомления\r\n        send_notification(instance, created=True)\r\n\r\n# Сигнал m2m_changed обрабатывает изменения связей many-to-many\r\n@receiver(m2m_changed, sender=Post.category.through)\r\ndef notify_subscribers_m2m(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    print('11111111111111111111111111111')\r\n    if action == 'post_add':  # обрабатываем только добавление категорий\r\n        # отправляем уведомления после добавления категорий\r\n        send_notification(instance)", "rating_post": 0.0}}, {"model": "news.post", "pk": 80, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T14:19:47.665Z", "heading": "ячсм", "text": "яычсчсячсячсячс", "rating_post": 0.0}}, {"model": "news.post", "pk": 81, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T14:31:42.281Z", "heading": "аевпырвапр", "text": "вапррррррррррррррррррррр", "rating_post": 0.0}}, {"model": "news.post", "pk": 82, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T14:38:57.656Z", "heading": "cvbcvb", "text": "cvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvbfgbdfbd", "rating_post": 0.0}}, {"model": "news.post", "pk": 83, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T14:43:02.127Z", "heading": "sdfsdf", "text": "asdfsda\r\n\r\n# Пользовательская промежуточная модель\r\nfrom .models import PostCategory\r\n\r\n@receiver(m2m_changed, sender=PostCategory)\r\ndef notify_on_category_change(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    if action == 'post_add':  # Обрабатываем только добавление категорий\r\n        print(\"Добавлены новые категории!\")\r\n        # Тут можно разместить любую логику обработки, например, отправку уведомлений\r\n        # Например, отправляем письмо администратору о добавлении новых категорий\r\n        send_mail(\r\n            subject=\"Добавлены новые категории!\",\r\n            message=f\"К посту {instance.post.title} добавлены новые категории.\",\r\n            from_email=settings.DEFAULT_FROM_EMAIL,\r\n            recipient_list=[\"admin@example.com\"]\r\n        )\r\nКак это работает:\r\nМы установили сигнал m2m_changed на промежуточную модель PostCategory.\r\nСигнал срабатывает, когда изменяется связь между Post и Category.\r\nУсловие action == 'post_add' гарантирует, что обработчик будет вызван только при добавлении новых категорий.\r\nОсновные преимущества:\r\nИспользуя собственную промежуточную модель, вы имеете полный контроль над логикой обработки изменений связей many-to-many.\r\nВозможность внедрить любую специфичную логику (например, подсчёт статистики, отправку уведомлений и т.д.) при изменении отношений.\r\nИтог:\r\nТеперь ваш сигнал m2m_changed будет корректно работать с пользовательской промежуточной моделью PostCategory, реагируя на любые изменения связей many-to-many.", "rating_post": 0.0}}, {"model": "news.post", "pk": 84, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T15:01:32.983Z", "heading": "AS", "text": "logger = logging.getLogger(__name__)\r\n\r\n@receiver(m2m_changed, sender=models.Post.category.through)\r\ndef notify_subscribers_m2m(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    print('11111111111111111111111111111')\r\n    if action == 'post_add':  # обрабатываем только добавление категорий\r\n        print(\"sdf\")# отправляем уведомления после добавления категорий\r\n        # send_notification(instance)\r\n\r\n@receiver(post_save, sender=Post)\r\ndef notify_subscribers(sender, instance, created, **kwargs):\r\n    \"\"\" Отправляет уведомления подписчикам при создании или изменении поста. :param sender: Модель отправителя (Post). :param instance: Экземпляр модели Post. :param created: Булевое значение, True - если объект создан, False - если изменён. \"\"\"\r\n    categories = instance.category.all", "rating_post": 0.0}}, {"model": "news.post", "pk": 85, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T15:47:52.197Z", "heading": "zdxc", "text": "zxccccccconnect() принимает обработчик (notify_subscribers_m2m) и указывает отправителя сигнала (Post.category.through).\r\nПараметр weak=False гарантирует, что обработчик сигнала не будет удалён сборщиком мусора и останется доступным для обработки будущих сигналов.\r\nСтоит ли менять ваш текущий код?\r\nЕсли у вас уже работает декоратор @receiver, нет необходимости переделывать его на метод connect(). Декоратор автоматически добавляет обработчик сигнала с параметрами по умолчанию, среди которых уже заложено правильное поведение для большинства случаев.", "rating_post": 0.0}}, {"model": "news.post", "pk": 86, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T15:48:39.817Z", "heading": "xdfvsdf", "text": "(social_account_added)\r\ndef add_to_common_group(sender, request, sociallogin, **kwargs):\r\n    user = sociallogin.user\r\n    try:\r\n        group = Group.objects.get(name='common')\r\n        group.user_set.add(user)\r\n    except Group.DoesNotExist:\r\n        pass\r\n\r\n\r\n\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\n@receiver(m2m_changed, weak=True, sender=Post.category.through)\r\ndef notify_subscribers_m2m(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    print('11111111111111111111111111111')\r\n    if action == 'post_add':  # обрабатываем только добавление категорий\r\n        print(\"sdf\")# отправляем уведомления после добавления категорий\r\n        # send_notification(instance)\r\n\r\n@receiver(post_save, sender=Post)\r\ndef notify_subscribers(sender, instance, created, **kwargs):\r\n    \"\"\" Отправляет уведомления подписчикам при создании или измен", "rating_post": 0.0}}, {"model": "news.post", "pk": 87, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T15:50:19.440Z", "heading": "осsdsd", "text": "class Post(models.Model):\r\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\r\n    article = models.BooleanField(default=False)\r\n    time_in = models.DateTimeField(auto_now_add=True)\r\n    category = models.ManyToManyField(Category, through='PostCategory')\r\n    heading = models.CharField(max_length=255, unique=True)\r\n    text = models.TextField()\r\n    rating_post = models.FloatField(default=0.0)\r\n\r\n    def __str__(self):\r\n        return f'{self.heading.title()}: {self.text[:20]}...'\r\n    def get_absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\n\r\n\r\n    def like(self):", "rating_post": 0.0}}, {"model": "news.post", "pk": 88, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T16:01:32.765Z", "heading": "яч", "text": "чччччrs = models.ManyToManyField(User, blank=True, related_name=\"subscribed_categories\")\r\n\r\n    def __str__(self):\r\n        return self.name.title()\r\n\r\n\r\n\r\nclass Post(models.Model):\r\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\r\n    article = models.BooleanField(default=False)\r\n    time_in = models.DateTimeField(auto_now_add=True)\r\n    category = models.ManyToManyField(Category, through='PostCategory')\r\n    heading = models.CharField(max_length=255, unique=True)\r\n    text = models.TextField()\r\n    rating_post = models.FloatField(default=0.0)\r\n\r\n    def __str__(self):\r\n        return f'{self.heading.title()}: {self.text[:20]}...'\r\n    def get_absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\n\r\n\r\n    def like(self):\r\n\r\n        self.rating_post += 1", "rating_post": 0.0}}, {"model": "news.post", "pk": 89, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T16:18:42.157Z", "heading": "wqedadsf", "text": "class Post(models.Model):\r\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\r\n    article = models.BooleanField(default=False)\r\n    time_in = models.DateTimeField(auto_now_add=True)\r\n    category = models.ManyToManyField(Category, through='PostCategory')\r\n    heading = models.CharField(max_length=255, unique=True)\r\n    text = models.TextField()\r\n    rating_post = models.FloatField(default=0.0)\r\n\r\n    def __str__(self):\r\n        return f'{self.heading.title()}: {self.text[:20]}...'\r\n    def get_absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\n\r\n\r\n    def like(self):\r\n\r\n        self.rating_post += 1\r\n        self.save()\r\n\r\n    def dislike(self):\r\n        if self.rating_post > 0:\r\n            self.rating_post -= 1\r\n            self.save()\r\n        else:\r\n            self.rating_post = 0\r\n            self.save()\r\n\r\n    def preview(self):\r\n        return self.text[0:124] + \"...\"\r\n\r\n\r\n\r\nclass PostCategory(models.Model):\r\n    post = models.ForeignKey(Post, on_delete=models.CASCADE)\r\n    category = models.ForeignKey(Category, on_delete=models.CASCADE)\r\n\r\n\r\nclass Comment(models.Model):\r\n    post = models.ForeignKey(Post, on_delete=models.CASCADE)\r\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\r\n    text = models.CharField(max_length=255)\r\n    time_create = models.DateTimeField(auto_now_add=True)\r\n    rating_com = models.FloatField(default=0.0)\r\n\r\n    def like(self):\r\n        self.rating_com += 1\r\n        self.save()\r\n\r\n    def dislike(self):\r\n\r\n        if self.rating_com > 0:\r\n            self.rating_com -= 1\r\n            self.save()\r\n        else:\r\n            self.rating_com = 0\r\n            self.save()", "rating_post": 0.0}}, {"model": "news.post", "pk": 90, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T16:33:21.126Z", "heading": "hgh", "text": "ghgh            self.rating_post = 0\r\n            self.save()\r\n\r\n    def preview(self):\r\n        return self.text[0:124] + \"...\"\r\n\r\n\r\n\r\nclass PostCategory(models.Model):\r\n    post = models.ForeignKey(Post, on_delete=models.CASCADE)\r\n    category = models.ForeignKey(Category, on_delete=models.CASCADE)\r\n\r\n\r\nclass Comment(models.Model):", "rating_post": 0.0}}, {"model": "news.post", "pk": 91, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T16:57:12.335Z", "heading": "sdfsdfcvbfghfghfghn", "text": "sdfsdfsdfsdfffffffffffffvghnbfdgnbhgfdhngdhndghnd", "rating_post": 0.0}}, {"model": "news.post", "pk": 92, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T16:57:36.961Z", "heading": "fsdghrwetyhertyjuhetyjhetyj", "text": "dfghfdhfdghsedshdfghdfghdfghdfghdfgjhwsrtyj5jmwsntyhstymhsmtyhnz ysmnrtzh", "rating_post": 0.0}}, {"model": "news.post", "pk": 93, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T17:00:45.623Z", "heading": "sgfd", "text": "category = models.ManyToManyField(Category, through='PostCategory')\r\n    heading = models.CharField(max_length=255, unique=True)\r\n    text = models.TextField()\r\n    rating_post = models.FloatField(default=0.0)\r\n\r\n    def __str__(self):\r\n        return f'{self.heading.title()}: {self.text[:20]}...'\r\n    def get_absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\n\r\n    def save(self, *args, **kwargs):\r\n        super().save(*args, **kwargs)\r\n        # Программно отправляем сигнал m2m_changed\r\n        m2m_changed.send(\r\n            sender=PostCategory,\r\n            instance=self,\r\n            action='post_add',\r\n            reverse=False,\r\n            model=Category,\r\n            pk_set=self.category.all(),\r\n        )\r\n\r\n    def like(self):\r\n\r\n        self.rating_post += 1\r\n        self.save()", "rating_post": 0.0}}, {"model": "news.post", "pk": 94, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T17:03:20.674Z", "heading": "тьборплбьпробпорл", "text": "msg.send()\r\n                logger.info(f\"Письмо отправлено на {email} успешно.\")\r\n            except Exception as e:\r\n                logger.error(f\"Ошибка отправки письма на {email}: {str(e)}\")\r\n\r\n# Сигнал post_save обрабатывает создание поста\r\n@receiver(post_save, sender=Post)\r\ndef notify_subscribers_post_save(sender, instance, created, **kwargs):\r\n    print(\"asddfasdasdasdasd\")\r\n    if created:\r\n        # Сразу после создания поста отправляем уведомления\r\n        send_notification(instance, created=True)\r\n\r\n# Сигнал m2m_changed обрабатывает изменения связей many-to-many\r\n@receiver(m2m_changed, sender=Post.category.through)\r\ndef notify_subscribers_m2m(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    print('11111111111111111111111111111')\r\n    if action == 'post_add':  # обрабатываем только добавление категорий\r\n        # отправляем уведомления после добавления категорий", "rating_post": 0.0}}, {"model": "news.post", "pk": 95, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T17:03:38.825Z", "heading": "пропропро", "text": "попаовпрооооооооооооооооооооооооооооооооооооооооооооооооьтттттттттттт", "rating_post": 0.0}}, {"model": "news.post", "pk": 96, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T17:04:55.901Z", "heading": "hjkhjkhjk", "text": "= models.TextField()\r\n    rating_post = models.FloatField(default=0.0)\r\n\r\n    def __str__(self):\r\n        return f'{self.heading.title()}: {self.text[:20]}...'\r\n    def get_absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\n\r\n    def save(self, *args, **kwargs):\r\n        super().save(*args, **kwargs)\r\n        # Программно отправляем сигнал m2m_changed\r\n        m2m_changed.send(\r\n            sender=PostCategory,\r\n            instance=self,\r\n            action='post_add',\r\n            reverse=False,\r\n            model=Category,\r\n            pk_set=self.category.all(),\r\n        )\r\n\r\n    def like(self):\r\n\r\n        self.rating_post += 1\r\n        self.save()\r\n\r\n    def dislike(self):\r\n        if self.rating_post > 0:\r\n            self.rating_post -= 1\r\n            self.save()\r\n        else:\r\n            self.rating_post = 0", "rating_post": 0.0}}, {"model": "news.post", "pk": 97, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T17:05:53.055Z", "heading": "sdfgadfgadfgadfg", "text": "from_email=settings.DEFAULT_FROM_EMAIL,\r\n                to=[email]\r\n            )\r\n            msg.attach_alternative(html_message, \"text/html\")\r\n\r\n            try:\r\n                msg.send()\r\n                logger.info(f\"Письмо отправлено на {email} успешно.\")\r\n            except Exception as e:\r\n                logger.error(f\"Ошибка отправки письма на {email}: {str(e)}\")\r\n\r\n# Сигнал post_save обрабатывает создание поста\r\n@receiver(post_save, sender=Post)\r\ndef notify_subscribers_post_save(sender, instance, created, **kwargs):\r\n    print(\"asddfasdasdasdasd\")\r\n    if created:\r\n        # Сразу после создания поста отправляем уведомления\r\n        send_notification(instance, created=True)\r\n\r\n# Сигнал m2m_changed обрабатывает изменения связей many-to-many\r\n@receiver(m2m_changed, sender=Post.category.through)\r\ndef notify_subscribers_m2m(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    print('11111111111111111111111111111')\r\n    if action == 'post_add':  # обрабатываем только добавление категорий\r\n        # отправляем уведомления после добавления категорий\r\n        print(instance.heading)", "rating_post": 0.0}}, {"model": "news.post", "pk": 98, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T17:08:43.728Z", "heading": "sefsdfsfsfd", "text": "if len(recipients) > 0:\r\n        subject = f\"{instance.heading}\"  # тема письма равна заголовку поста\r\n        event_type = \"Создана новая запись\" if created else \"Изменена запись\"\r\n        text_body = f'{instance.text[:50]}...'  # первые 50 символов текста\r\n        category_names = ', '.join([cat.name for cat in categories])  # список категорий\r\n\r\n        # Формирование письма\r\n        for email in recipients:\r\n            user = next((sub for sub in subscribers if sub.email == email), None)\r\n            if not user:\r\n                continue  # пропускаем пользователя, если не найден\r\n\r\n            html_message = render_to_string('message_template.html', {\r\n                'type_event': event_type,\r\n                'username': user.username,\r\n                'categories': category_names,\r\n                'subject': subject,\r\n                'body_text': text_body\r\n            })\r\n\r\n            # Создание и отправка письма\r\n            msg = EmailMultiAlternatives(\r\n                subject=f'News Portal: {subject}',", "rating_post": 0.0}}, {"model": "news.post", "pk": 99, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T17:10:08.949Z", "heading": "asdfsdafasdfsdaffdssdf", "text": "absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\n\r\n    def save(self, *args, **kwargs):\r\n        super().save(*args, **kwargs)\r\n        # Программно отправляем сигнал m2m_changed\r\n        m2m_changed.send(\r\n            sender=PostCategory,\r\n            instance=self,\r\n            action='post_add',\r\n            reverse=False,\r\n            model=Category,\r\n            pk_set=self.category.all(),\r\n        )\r\n\r\n    def like(self):\r\n\r\n        self.rating_post += 1\r\n        self.save()\r\n\r\n    def dislike(self):\r\n        if self.rating_post > 0:\r\n            self.rating_post -= 1", "rating_post": 0.0}}, {"model": "news.post", "pk": 100, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T17:11:49.227Z", "heading": "tdyj ghb", "text": "absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\n\r\n    def save(self, *args, **kwargs):\r\n        super().save(*args, **kwargs)\r\n        # Программно отправляем сигнал m2m_changed\r\n        m2m_changed.send(\r\n            sender=PostCategory,\r\n            instance=self,\r\n            action='post_add',\r\n            reverse=False,\r\n            model=Category,\r\n            pk_set=self.category.all(),\r\n        )\r\n\r\n    def like(self):\r\n\r\n        self.rating_post += 1\r\n        self.save()\r\n\r\n    def dislike(self):\r\n        if self.rating_post > 0:\r\n            self.rating_post -= 1", "rating_post": 0.0}}, {"model": "news.post", "pk": 101, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T17:15:57.188Z", "heading": "gggg", "text": "absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\n\r\n    def save(self, *args, **kwargs):\r\n        super().save(*args, **kwargs)\r\n        # Программно отправляем сигнал m2m_changed\r\n        m2m_changed.send(\r\n            sender=PostCategory,\r\n            instance=self,tyhg\r\n            action='post_add',\r\n            reverse=False,\r\n            model=Category,\r\n            pk_set=self.category.all(),\r\n        )\r\n\r\n    def like(self):\r\n\r\n        self.rating_post += 1\r\n        self.save()\r\n\r\n    def dislike(self):\r\n        if self.rating_post > 0:\r\n            self.rating_post -= 1", "rating_post": 0.0}}, {"model": "news.post", "pk": 102, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T17:32:19.972Z", "heading": "awdawd", "text": "asfdasfsadfasdgsdg\r\n\r\n    def __str__(self):\r\n        return f'{self.heading.title()}: {self.text[:20]}...'\r\n    def get_absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\n\r\n    def save(self, *args, **kwargs):\r\n        super().save(*args, **kwargs)\r\n        # Программно отправляем сигнал m2m_changed\r\n        m2m_changed.send(\r\n            sender=PostCategory,\r\n            instance=self,\r\n            action='post_add',\r\n            reverse=False,\r\n            model=Category,\r\n            pk_set=self.category.all(),\r\n        )\r\n\r\n    def like(self):\r\n\r\n        self.rating_post += 1\r\n        self.s", "rating_post": 0.0}}, {"model": "news.post", "pk": 103, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T17:50:24.056Z", "heading": "фывчфыфысфыс", "text": "фыthor = models.ForeignKey(Author, on_delete=models.CASCADE)\r\n    article = models.BooleanField(default=False)\r\n    time_in = models.DateTimeField(auto_now_add=True)\r\n    category = models.ManyToManyField(Category, through='PostCategory')\r\n    heading = models.CharField(max_length=255, unique=True)\r\n    text = models.TextField()\r\n    rating_post = models.FloatField(default=0.0)\r\n\r\n    def __str__(self):\r\n        return f'{self.heading.title()}: {self.text[:20]}...'\r\n    def get_absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\n\r\n    def save(self, *args, **kwargs):\r\n        super().save(*args, **kwargs)\r\n        # Программно отправляем сигнал m2m_changed\r\n        m2m_changed.send(\r\n            sender=PostCategory,", "rating_post": 0.0}}, {"model": "news.post", "pk": 104, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T17:53:17.459Z", "heading": "вапвыапимвфапирываывс", "text": "ывамсывапимывяаимчсмчсмчсмчсмвкаымпи", "rating_post": 0.0}}, {"model": "news.post", "pk": 105, "fields": {"author": 3, "article": false, "time_in": "2025-07-06T17:56:34.026Z", "heading": "dfgsdfgsd", "text": "class Comment(models.Model):\r\n    post = models.ForeignKey(Post, on_delete=models.CASCADE)\r\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\r\n    text = models.CharField(max_length=255)\r\n    time_create = models.DateTimeField(auto_now_add=True)\r\n    rating_com = models.FloatField(default=0.0)\r\n\r\n    def like(self):\r\n        self.rating_com += 1\r\n        self.save()\r\n\r\n    def dislike(self):\r\n\r\n        if self.rating_com > 0:\r\n            self.rating_com -= 1", "rating_post": 0.0}}, {"model": "news.post", "pk": 106, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T17:59:45.235Z", "heading": "sdfasfasdfsadf", "text": "asddfasdf\r\n    def __str__(self):\r\n        return f'{self.heading.title()}: {self.text[:20]}...'\r\n    def get_absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\n\r\n    def save(self, *args, **kwargs):\r\n        super().save(*args, **kwargs)\r\n        # Программно отправляем сигнал m2m_changed\r\n        m2m_changed.send(\r\n            sender=PostCategory,\r\n            instance=self,\r\n            action='post_add',\r\n            reverse=False,\r\n            model=Category,\r\n            pk_set=self.category.all()", "rating_post": 0.0}}, {"model": "news.post", "pk": 107, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T18:00:04.717Z", "heading": "asdasdasd", "text": "def __str__(self):\r\n        return f'{self.heading.title()}: {self.text[:20]}...'\r\n    def get_absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\nser\r\n    def save(self, *args, **kwargs):\r\n        super().save(*args, **kwargs)\r\n        # Программно отправляем сигнал m2m_changed\r\n        m2m_changed.send(\r\n            sender=PostCategory,\r\n            instance=self,\r\n            action='post_add',\r\n            reverse=False,\r\n            model=Category,\r\n            pk_set=self.category.all()", "rating_post": 0.0}}, {"model": "news.post", "pk": 108, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T18:00:47.752Z", "heading": "sdfsdfsedf", "text": "g.attach_alternative(html_message, \"text/html\")\r\n\r\n            try:\r\n                msg.send()\r\n                logger.info(f\"Письмо отправлено на {email} успешно.\")\r\n            except Exception as e:\r\n                logger.error(f\"Ошибка отправки письма на {email}: {str(e)}\")\r\n\r\n\r\n# Сигнал post_save обрабатывает создание поста\r\n@receiver(post_save, sender=Post)\r\ndef notify_subscribers_post_save(sender, instance, created, **kwargs):\r\n    if created:\r\n        # Сразу после создания поста отправляем уведомления\r\n        send_notification(instance, created=True)\r\n\r\n\r\n# Сигнал m2m_changed обрабатывает изменения связей many-to-many\r\n@receiver(m2m_changed, sender=Post.category.through, weak= False)\r\ndef notify_subscribers_m2m(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    if action == 'post_add':  # обрабатываем только добавление категорий\r\n        # отправляем уведомления после добавления категорий\r\n        print(instance.heading, instance.category.first())\r\n        send_notification(instance)", "rating_post": 0.0}}, {"model": "news.post", "pk": 109, "fields": {"author": 1, "article": false, "time_in": "2025-07-06T18:07:25.982Z", "heading": "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb", "text": "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb", "rating_post": 0.0}}, {"model": "news.post", "pk": 118, "fields": {"author": 1, "article": false, "time_in": "2025-07-07T19:21:49.549Z", "heading": "AsxZXZX", "text": "# Создание и отправка письма\r\n            msg = EmailMultiAlternatives(\r\n                subjeAct=f'News Portal: {subject}',\r\n                body='',  # пустой текст, так как используем HTML\r\n                from_email=settings.DEFAULT_FROM_EMAIL,\r\n                to=[email]\r\n            )\r\n            msg.attach_alternative(html_message, \"text/html\")\r\n\r\n            try:\r\n                msg.send()\r\n                logger.info(f\"Письмо отправлено на {email} успешно.\")\r\n            except Exception as e:\r\n                logger.error(f\"Ошибка отправки письма на {email}: {str(e)}\")\r\n\r\n\r\n# Сигнал post_save обрабатывает создание поста\r\n@receiver(post_save, sender=Post)\r\ndef notify_subscribers_post_save(sender, instance, created, **kwargs):\r\n    if created:\r\n        # Сразу после создания поста отправляем уведомления\r\n        send_notification(instance, created=True)\r\n\r\n\r\n# Сигнал m2m_changed обрабатывает изменения связей many-to-many\r\n@receiver(m2m_changed, sender=Post.category.through, weak= False)\r\ndef notify_subscribers_m2m(sender, instance, action, reverse, model, pk_set, **kwargs):\r\n    if action == 'post_add':  # обрабатываем только добавление категорий\r\n        # отправляем уведомления после добавления категорий\r\n        print(instance.heading, instance.category.first())", "rating_post": 0.0}}, {"model": "news.post", "pk": 119, "fields": {"author": 3, "article": false, "time_in": "2025-07-07T19:26:18.555Z", "heading": "zxczxc", "text": "st(models.Model):\r\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\r\n    article = models.BooleanField(default=False)\r\n    time_in = models.DateTimeField(auto_now_add=True)\r\n    category = models.ManyToManyField(Category, through='PostCategory')\r\n    heading = models.CharField(max_length=255, unique=True)\r\n    text = models.TextField()\r\n    rating_post = models.FloatField(default=0.0)\r\n\r\n    def __str__(self):\r\n        return f'{self.heading.title()}: {self.text[:20]}...'\r\n    def get_absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\n\r\n    def save(self, *args, **kwargs):", "rating_post": 0.0}}, {"model": "news.post", "pk": 120, "fields": {"author": 3, "article": false, "time_in": "2025-07-07T19:28:12.015Z", "heading": "asdasdasdasd", "text": "egory = models.ManyToManyField(Category, through='PostCategory')\r\n    heading = models.CharField(max_length=255, unique=True)\r\n    text = models.TextField()\r\n    rating_post = models.FloatField(default=0.0)\r\n\r\n    def __str__(self):\r\n        return f'{self.heading.title()}: {self.text[:20]}...'\r\n    def get_absolute_url(self):\r\n        return reverse('post_detail', args=[str(self.id)])\r\n\r\n    # def save(self, *args, **kwargs):\r\n    #     super().save(*args, **kwargs)\r\n    #     # Программно отправляем сигнал m2m_changed\r\n    #     m2m_changed.send(\r\n    #         sender=PostCategory,\r\n    #         instance=self,\r\n    #         action='post_add',", "rating_post": 0.0}}, {"model": "news.post", "pk": 192, "fields": {"author": 8, "article": false, "time_in": "2025-08-08T23:51:06.216Z", "heading": "ачсмивифавиф", "text": "вяаифваят яптчаптчапт", "rating_post": 0.0}}, {"model": "news.post", "pk": 193, "fields": {"author": 8, "article": false, "time_in": "2025-08-08T23:52:46.298Z", "heading": "234234", "text": "234цфваы", "rating_post": 0.0}}, {"model": "news.post", "pk": 194, "fields": {"author": 8, "article": false, "time_in": "2025-08-08T23:55:23.746Z", "heading": "аымвив", "text": "вамвамв", "rating_post": 0.0}}, {"model": "news.post", "pk": 195, "fields": {"author": 6, "article": false, "time_in": "2025-08-09T22:38:26.841Z", "heading": "ljk", "text": "fghfgjfhjfjg", "rating_post": 0.0}}, {"model": "news.post", "pk": 196, "fields": {"author": 6, "article": false, "time_in": "2025-08-18T08:19:19.039Z", "heading": "кеш", "text": "60 секунд", "rating_post": 0.0}}, {"model": "news.post", "pk": 197, "fields": {"author": 6, "article": false, "time_in": "2025-08-18T08:20:57.497Z", "heading": "кеш 180", "text": "кеш 180 секуннд", "rating_post": 0.0}}, {"model": "news.post", "pk": 198, "fields": {"author": 6, "article": false, "time_in": "2025-08-18T08:21:40.686Z", "heading": "кеши", "text": "сячясяч яч", "rating_post": 0.0}}]
